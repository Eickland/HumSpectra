from pathlib import Path
import os
from typing import Callable, Dict, Sequence, Union, Optional, Mapping, Tuple
from functools import wraps
import copy
import json
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from scipy import spatial
from scipy.optimize import curve_fit
from scipy.spatial import cKDTree
from functools import lru_cache
from joblib import Parallel, delayed
from tqdm import tqdm


import HumSpectra.utilits as ut
from HumSpectra.brutto import brutto_gen, elements_table, get_elements_masses

def read_mass_list(path: str,
                 sep: str = None,
                 **kwargs) -> pd.DataFrame:
    """
    :param path: путь к файлу в строчном виде,
            (example: "C:/Users/mnbv2/Desktop/lab/KNP work directory/Флуоресценция/ADOM-SL2-1.csv").
    :param sep: разделитель в строчном виде (example: ",").
    :return: DataFrame: 
    """
    if sep is None:
        sep = ut.check_sep(path)
    try:
        data = pd.read_csv(path, sep=sep, **kwargs)
    except FileNotFoundError:
        raise FileNotFoundError(f"Файл не найден: {path}")
    except pd.errors.EmptyDataError:
        raise pd.errors.EmptyDataError(f"Файл пуст: {path}")
    except Exception as e:
        raise Exception(f"Ошибка при чтении файла: {e}")
    data.dropna(inplace=True, axis=1)
    data = data.astype("float64")
    name = ut.extract_name_from_path(path)
    data.attrs['name'] = name


    return data


def assign(data: pd.DataFrame,
            brutto_dict: Optional[dict] = None,
            generated_bruttos_table: Optional[pd.DataFrame] = None,
            rel_error: Optional[float] = None,
            abs_error: Optional[float] = None,
            sign: str ='-',
            mass_min: Optional[float] =  None,
            mass_max: Optional[float] = None,
            intensity_min: Optional[float] =  None,
            intensity_max: Optional[float] = None,
            charge_max: int = 1,
            n_jobs=-1
    ) -> pd.DataFrame:
        """
        Assigning brutto formulas to signal by mass
        
        Parameters
        -----------
        brutto_dict: dict
            Optional. Deafault None.
            Custom Dictonary for generate brutto table.
            Example: {'C':(4, 51),'H':(4, 101),'O':(0,26), 'N':(0,4), 'C_13':(0,3)}
        generated_bruttos_table: pandas DataFrame 
            Optional. Contain column 'mass' and elements, 
            should be sorted by 'mass'.
            Can be generated by function brutto_generator.brutto_gen(). 
            if 'None' generate table with default elemnets and ranges
            C: 4-50, H 4-100, O 0-25, N 0-3, S 0-2.
        rel_error: float
            Optional. default 0.5, permissible error in ppm for assign mass to brutto formulas
        abs_error: float
            Optional. default None, permissible absolute error for assign mass to brutto formulas
        sign: str
            Optional. Deafult '-'.
            Mode in which mass spectrum was gotten. 
            '-' for negative mode
            '+' for positive mode
            '0' for neutral
        mass_min: float
            Optional. Default None. Minimall mass for assigment
        mass_max: float
            Optional. Default None. Maximum mass for assigment
        intensity_min: float
            Optional. Default None. Minimall intensity for assigment
        intensity_max: float
            Optional. Default None. Maximum intensity for assigment
        charge_max: int
            Maximum charge in m/z. Default 1.   

        Return
        ------
        pd.DataFrame 
        """

        if generated_bruttos_table is None:
            generated_bruttos_table = brutto_gen(brutto_dict)

        if mass_min is None:
            mass_min = data['mass'].min()
        if mass_max is None:
            mass_max = data['mass'].max()
        if intensity_min is None:
            intensity_min = data['intensity'].min()
        if intensity_max is None:
            intensity_max = data['intensity'].max()
        
        if sign == '-':
            mass_shift = - 0.00054858 + 1.007825  # electron and hydrogen mass
        elif sign == '+':
            mass_shift = 0.00054858  # electron mass
        elif sign == '0':
            mass_shift = 0
        else:
            raise Exception('Sended sign to assign method is not correct. May be "+","-","0"')

        data.attrs['sign'] = sign

        if rel_error is not None:
            rel = True
        if abs_error is not None:
            rel = False
        if rel_error is not None and abs_error is not None:
            raise Exception('one of rel_error or abs_error must be None in assign method')
        if rel_error is None and abs_error is None:
            rel = True
            rel_error = 0.5

        data = data.loc[:,['mass', 'intensity']].reset_index(drop=True)
        table = data.copy()

        masses = generated_bruttos_table["mass"].values

        elems = list(generated_bruttos_table.drop(columns=["mass"]))
        bruttos = generated_bruttos_table[elems].values.tolist()

        res = []
        for index, row in table.iterrows():

            if (row["mass"] < mass_min or 
                row["mass"] > mass_max or
                row["intensity"] < intensity_min or 
                row["intensity"] > intensity_max):
                res.append({"assign": False})
                continue 
            
            for charge in range(1, charge_max + 1):
                mass = (row["mass"] + mass_shift) * charge
                idx = np.searchsorted(masses, mass, side='left')
                if idx > 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) < np.fabs(mass - masses[idx])):
                    idx -= 1

                if rel:
                    if np.fabs(masses[idx] - mass) / mass * 1e6 <= rel_error/charge:
                        res.append({**dict(zip(elems, bruttos[idx])), "assign": True, "charge": charge})
                        break
                else:
                    if np.fabs(masses[idx] - mass) <= abs_error/charge:
                        res.append({**dict(zip(elems, bruttos[idx])), "assign": True, "charge": charge})
                        break
            else:
                res.append({"assign": False, "charge": 1})

        res = pd.DataFrame(res)

        table = table.join(res)
        data = data.merge(table, how='outer', on=list(data.columns))
        data['assign'] = data['assign'].fillna(False)
        data['charge'] = data['charge'].fillna(1)

        return data


def _copy(func):
    """
    Decorator for deep copy pd.DataFrame before apllying methods
    
    Parameters
    ----------
    func: method
        function for decoarate
    
    Return
    ------
    function with deepcopyed pd.DataFrame
    """

    @wraps(func)
    def wrapper(dataframe, *args, **kwargs):
        # Создаем глубокую копию DataFrame
        dataframe_copy = copy.deepcopy(dataframe)
        
        # Вызываем оригинальную функцию с копией
        result = func(dataframe_copy, *args, **kwargs)
        
        return result
    
    return wrapper

@_copy
def noise_filter(self,
                    force: float = 1.5,
                    intensity: Optional[float] = None,
                    quantile: Optional[float] = None 
                    ) -> pd.DataFrame:
    """
    Remove noise from spectrum

    Parameters
    ----------
    intensity: float
        Cut by min intensity. 
        Default None and dont apply.
    quantile: float
        Cut by quantile. For example 0.1 mean that 10% 
        of peaks with minimal intensity will be cutted. 
        Default None and dont aplly
    force: float
        How many peaks should cut when auto-search noise level.
        Default 1.5 means that peaks with intensity more 
        than noise level*1.5 will be cutted
    
    Return
    ------
    pd.DataFrame

    Caution
    -------
    There is risk of loosing data. Do it cautiously.
    Level of noise may be determenided wrong. 
    Draw and watch spectrum.
    """
    
    if intensity is not None:
        self = self.loc[self['intensity'] > intensity].reset_index(drop=True)
        self.attrs['noise filter (intensity)'] = intensity
    
    elif quantile is not None:
        tresh = self['intensity'].quantile(quantile)
        self = self.loc[self['intensity'] > tresh].reset_index(drop=True)
        self.attrs['noise filter (quantile)'] = quantile
        
    
    else:

        intens = self['intensity'].values
        cut_diapasone=np.linspace(0, np.mean(intens),100)

        d = []
        for i in cut_diapasone:
            d.append(len(intens[intens > i]))

        dx = np.gradient(d, 1)
        tresh = np.where(dx==np.min(dx))
        cut = cut_diapasone[tresh[0][0]] * force
        self = self.loc[self['intensity'] > cut].reset_index(drop=True)

        self.attrs['noise filter (force)'] = force

    return self

@_copy
def drop_unassigned(self) -> "pd.DataFrame":
    """
    Drop unassigned by brutto rows

    Return
    ------
    pd.DataFrame

    Caution
    -------
    Danger of lose data - with these operation we exclude data that can be usefull
    """

    if "assign" not in self:
        raise Exception("Spectrum is not assigned")

    self = self.loc[self["assign"] == True].reset_index(drop=True)
    self.attrs['drop_unassigned'] = True

    return self

@_copy
def merge_duplicates(self) -> "pd.DataFrame":
    """
    merge duplicataes with the same calculated mass with sum intensity

    Return
    ------
    pd.DataFrame
    """
    if 'calc_mass' not in self.columns:
        self = self.calc_mass()

    cols = {col: ('sum' if col=='intensity' else 'max') for col in self.columns}
    self = self.groupby(['calc_mass'],as_index = False).agg(cols)
    return self

@_copy
def filter_by_C13(
    self, 
    rel_error: float = 0.5,
    remove: bool = False,
) -> pd.DataFrame:
    """ 
    Check if peaks have the same brutto with C13 isotope

    Parameters
    ----------
    rel_error: float
        Optional. Default 0.5.
        Allowable ppm error when checking c13 isotope peak
    remove: bool
        Optional, default False. 
        Drop unassigned peaks and peaks without C13 isotope
    
    Return
    ------
    pd.DataFrame
    """
    
    self = self.sort_values(by='mass').reset_index(drop=True)
    
    flags = np.zeros(self.shape[0], dtype=bool)
    masses = self["mass"].values
    
    C13_C12 = 1.003355  # C13 - C12 mass difference

    
    for index, row in self.iterrows():
        mass = row["mass"] + C13_C12
        error = mass * rel_error * 0.000001

        idx = np.searchsorted(masses, mass, side='left')
        
        if idx > 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) < np.fabs(mass - masses[idx])):
            idx -= 1
        
        if np.fabs(masses[idx] - mass)  <= error:
            flags[index] = True
    
    self['C13_peak'] = flags

    if remove:
        self = self.loc[(self['C13_peak'] == True) & (self['assign'] == True)].reset_index(drop=True)
        self.attrs['filter_C13'] = True
        

    return self

@_copy
def normalize(self, how:str='sum') -> pd.DataFrame:
    """
    Intensity normalize by intensity

    Parameters
    ----------
    how: {'sum', 'max', 'median', 'mean'}
        'sum' for normilize by sum of intensity of all peaks. (default)
        'max' for normilize by higher intensity peak.
        'median' for normilize by median of peaks intensity.
        'mean' for normilize by mean of peaks intensity.

    Return
    ------
    pd.DataFrame
    """

    if how=='max':
        self['intensity'] /= self['intensity'].max()
    elif how=='sum':
        self['intensity'] /= self['intensity'].sum()
    elif how=='median':
        self['intensity'] /= self['intensity'].median()
    elif how=='mean':
        self['intensity'] /= self['intensity'].mean()
    else:
        raise Exception(f"There is no such mode: {how}")
    
    self.attrs['normilize'] = how

    return self

@_copy
def merge_isotopes(self) -> "pd.DataFrame":
    """
    Merge isotopes.

    For example if specrum list have 'C' and 'C_13' they will be summed in 'C' column.

    Return
    ------
    pd.DataFrame

    Caution
    -------
    Danger of lose data - with these operation we exclude data that can be usefull       
    """

    elems = self.find_elements()
    for el in elems:
        res = el.split('_')
        if len(res) == 2:
            if res[0] not in self:
                self[res[0]] = 0
            self[res[0]] = self[res[0]] + self[el]
            self = self.drop(columns=[el])
    
    self.attrs['merge_isotopes'] = True

    return self