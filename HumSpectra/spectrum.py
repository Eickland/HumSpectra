from typing import Callable, Dict, Sequence, Union, Optional, Mapping, Tuple, Any
from functools import wraps
import copy
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from scipy.optimize import curve_fit
from matplotlib.axes import Axes

import HumSpectra.utilits as ut
from HumSpectra.brutto import brutto_gen, elements_table, get_elements_masses

def read_mass_list(path: str,
                map_columns: dict|None = {"m/z":"mass","I":"intensity"},
                custom_columns_name: bool = False,
                sep: str|None = "\t",
                **kwargs) -> pd.DataFrame:
    """
    :param path: путь к файлу в строчном виде,
            (example: "C:/Users/mnbv2/Desktop/lab/KNP work directory/Флуоресценция/ADOM-SL2-1.csv").
    :param sep: разделитель в строчном виде (example: ",").
    :return: DataFrame: 
    """
    if sep is None:
        sep = ut.check_sep(path)
    try:
        data = pd.read_csv(path, sep=sep, **kwargs)
    except FileNotFoundError:
        raise FileNotFoundError(f"Файл не найден: {path}")
    except pd.errors.EmptyDataError:
        raise pd.errors.EmptyDataError(f"Файл пуст: {path}")
    except Exception as e:
        raise Exception(f"Ошибка при чтении файла: {e}")
    
    if custom_columns_name:
        data.rename(columns=map_columns,inplace=True)

        data = data[["mass","intensity"]]

    data.dropna(inplace=True, axis=1)
    data = data.astype("float64")
    name = ut.extract_name_from_path(path)
    data.attrs['name'] = name

    return data

def find_elements(self) -> Sequence[str]:
    """ 
    Find elements from columns of mass spectrum table.

    For example, column 'C' will be recognised as carbon 12C, column 'C_13" as 13C

    Returns
    -------
    list
    """

    main_elems = elements_table()['element'].values
    all_elems = elements_table()['element_isotop'].values

    elems = []
    for col in self.columns:
        if col in main_elems:
            elems.append(col)
        elif col in all_elems:
            elems.append(col)

    if len(elems) == 0:
        elems = ""

    self.attrs['elems'] = elems

    return elems

def _mark_assigned_by_brutto(self) -> None:
    """
    Mark peaks in loaded mass list if they have brutto

    Return
    ------
    Spectrum
    """

    assign = []
    elems = find_elements(self)
    for i, row in self.iterrows():
        flag = False
        for el in elems:
            if row[el] > 0:
                flag = True
        assign.append(flag) 
    self['assign'] = assign

def assign(data: pd.DataFrame,
            brutto_dict: Any|None = None,
            generated_bruttos_table: Optional[pd.DataFrame] = None,
            rel_error: float|None = 0.5,
            abs_error: float|None = None,
            sign: str ='-',
            mass_min: Optional[float] =  None,
            mass_max: Optional[float] = None,
            intensity_min: Optional[float] =  None,
            intensity_max: Optional[float] = None,
            charge_max: int = 1,
            n_jobs=-1
    ) -> pd.DataFrame:
        """
        Assigning brutto formulas to signal by mass
        
        Parameters
        -----------
        brutto_dict: dict
            Optional. Deafault None.
            Custom Dictonary for generate brutto table.
            Example: {'C':(4, 51),'H':(4, 101),'O':(0,26), 'N':(0,4), 'C_13':(0,3)}
        generated_bruttos_table: pandas DataFrame 
            Optional. Contain column 'mass' and elements, 
            should be sorted by 'mass'.
            Can be generated by function brutto_generator.brutto_gen(). 
            if 'None' generate table with default elemnets and ranges
            C: 4-50, H 4-100, O 0-25, N 0-3, S 0-2.
        rel_error: float
            Optional. default 0.5, permissible error in ppm for assign mass to brutto formulas
        abs_error: float
            Optional. default None, permissible absolute error for assign mass to brutto formulas
        sign: str
            Optional. Deafult '-'.
            Mode in which mass spectrum was gotten. 
            '-' for negative mode
            '+' for positive mode
            '0' for neutral
        mass_min: float
            Optional. Default None. Minimall mass for assigment
        mass_max: float
            Optional. Default None. Maximum mass for assigment
        intensity_min: float
            Optional. Default None. Minimall intensity for assigment
        intensity_max: float
            Optional. Default None. Maximum intensity for assigment
        charge_max: int
            Maximum charge in m/z. Default 1.   

        Return
        ------
        pd.DataFrame 
        """

        name = data.attrs['name']

        if generated_bruttos_table is None:
            generated_bruttos_table = brutto_gen(brutto_dict)

        if mass_min is None:
            mass_min = data['mass'].min()
        if mass_max is None:
            mass_max = data['mass'].max()
        if intensity_min is None:
            intensity_min = data['intensity'].min()
        if intensity_max is None:
            intensity_max = data['intensity'].max()
        
        if sign == '-':
            mass_shift = - 0.00054858 + 1.007825  # electron and hydrogen mass
        elif sign == '+':
            mass_shift = 0.00054858  # electron mass
        elif sign == '0':
            mass_shift = 0
        else:
            raise Exception('Sended sign to assign method is not correct. May be "+","-","0"')

        data.attrs['sign'] = sign

        if rel_error is not None and abs_error is not None:
            raise Exception('one of rel_error or abs_error must be None in assign method')
        
        if rel_error is not None:
            rel = True
        elif abs_error is not None:
            rel = False
        else:
            rel = True

        data = data.loc[:,['mass', 'intensity']].reset_index(drop=True)
        table = data.copy(deep=True)

        masses = np.array(generated_bruttos_table["mass"].values)

        elems = list(generated_bruttos_table.drop(columns=["mass"]))
        bruttos = generated_bruttos_table[elems].values.tolist()

        res = []
        for index, row in table.iterrows():

            if (row["mass"] < mass_min or 
                row["mass"] > mass_max or
                row["intensity"] < intensity_min or 
                row["intensity"] > intensity_max):
                res.append({"assign": False})
                continue 
            
            for charge in range(1, charge_max + 1):
                mass = (row["mass"] + mass_shift) * charge
                idx = np.searchsorted(masses, mass, side='left')
                if idx > 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) < np.fabs(mass - masses[idx])):
                    idx -= 1

                if rel:
                    if np.fabs(masses[idx] - mass) / mass * 1e6 <= rel_error/charge: # type: ignore
                        res.append({**dict(zip(elems, bruttos[idx])), "assign": True, "charge": charge})
                        break
                else:
                    if np.fabs(masses[idx] - mass) <= abs_error/charge: # type: ignore
                        res.append({**dict(zip(elems, bruttos[idx])), "assign": True, "charge": charge})
                        break
            else:
                res.append({"assign": False, "charge": 1})

        res = pd.DataFrame(res)

        table = table.join(res)
        data = data.merge(table, how='outer', on=list(data.columns))
        data['assign'] = data['assign'].fillna(False)
        data['charge'] = data['charge'].fillna(1)
        data.attrs['name'] = name

        return data

def _copy(func):
    """
    Decorator for deep copy pd.DataFrame before apllying methods
    
    Parameters
    ----------
    func: method
        function for decoarate
    
    Return
    ------
    function with deepcopyed pd.DataFrame
    """

    @wraps(func)
    def wrapper(dataframe, *args, **kwargs):
        # Создаем глубокую копию DataFrame
        dataframe_copy = copy.deepcopy(dataframe)
        
        # Вызываем оригинальную функцию с копией
        result = func(dataframe_copy, *args, **kwargs)
        
        return result
    
    return wrapper

@_copy
def noise_filter(self,
                    force: float = 1.5,
                    intensity: Optional[float] = None,
                    quantile: Optional[float] = None 
                    ) -> pd.DataFrame:
    """
    Remove noise from spectrum

    Parameters
    ----------
    intensity: float
        Cut by min intensity. 
        Default None and dont apply.
    quantile: float
        Cut by quantile. For example 0.1 mean that 10% 
        of peaks with minimal intensity will be cutted. 
        Default None and dont aplly
    force: float
        How many peaks should cut when auto-search noise level.
        Default 1.5 means that peaks with intensity more 
        than noise level*1.5 will be cutted
    
    Return
    ------
    pd.DataFrame

    Caution
    -------
    There is risk of loosing data. Do it cautiously.
    Level of noise may be determenided wrong. 
    Draw and watch spectrum.
    """
    
    if intensity is not None:
        self = self.loc[self['intensity'] > intensity].reset_index(drop=True)
        self.attrs['noise filter (intensity)'] = intensity
    
    elif quantile is not None:
        tresh = self['intensity'].quantile(quantile)
        self = self.loc[self['intensity'] > tresh].reset_index(drop=True)
        self.attrs['noise filter (quantile)'] = quantile
        
    
    else:

        intens = self['intensity'].values
        cut_diapasone=np.linspace(0, np.mean(intens),100)

        d = []
        for i in cut_diapasone:
            d.append(len(intens[intens > i]))

        dx = np.gradient(d, 1)
        tresh = np.where(dx==np.min(dx))
        cut = cut_diapasone[tresh[0][0]] * force
        self = self.loc[self['intensity'] > cut].reset_index(drop=True)

        self.attrs['noise filter (force)'] = force

    return self

@_copy
def drop_unassigned(self) -> "pd.DataFrame":
    """
    Drop unassigned by brutto rows

    Return
    ------
    pd.DataFrame

    Caution
    -------
    Danger of lose data - with these operation we exclude data that can be usefull
    """

    if "assign" not in self:
        raise Exception("Spectrum is not assigned")

    self = self.loc[self["assign"] == True].reset_index(drop=True)
    self.attrs['drop_unassigned'] = True

    return self

@_copy
def merge_duplicates(self) -> "pd.DataFrame":
    """
    merge duplicataes with the same calculated mass with sum intensity

    Return
    ------
    pd.DataFrame
    """
    if 'calc_mass' not in self.columns:
        self = calc_mass(self)

    cols = {col: ('sum' if col=='intensity' else 'max') for col in self.columns}
    self = self.groupby(['calc_mass'],as_index = False).agg(cols)
    return self

@_copy
def filter_by_C13(
    self, 
    rel_error: float = 0.5,
    remove: bool = False,
) -> pd.DataFrame:
    """ 
    Check if peaks have the same brutto with C13 isotope

    Parameters
    ----------
    rel_error: float
        Optional. Default 0.5.
        Allowable ppm error when checking c13 isotope peak
    remove: bool
        Optional, default False. 
        Drop unassigned peaks and peaks without C13 isotope
    
    Return
    ------
    pd.DataFrame
    """
    
    self = self.sort_values(by='mass').reset_index(drop=True)
    
    flags = np.zeros(self.shape[0], dtype=bool)
    masses = self["mass"].values
    
    C13_C12 = 1.003355  # C13 - C12 mass difference

    
    for index, row in self.iterrows():
        mass = row["mass"] + C13_C12
        error = mass * rel_error * 0.000001

        idx = np.searchsorted(masses, mass, side='left')
        
        if idx > 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) < np.fabs(mass - masses[idx])):
            idx -= 1
        
        if np.fabs(masses[idx] - mass)  <= error:
            flags[index] = True
    
    self['C13_peak'] = flags

    if remove:
        self = self.loc[(self['C13_peak'] == True) & (self['assign'] == True)].reset_index(drop=True)
        self.attrs['filter_C13'] = True
        

    return self

@_copy
def normalize(self, how:str='sum') -> pd.DataFrame:
    """
    Intensity normalize by intensity

    Parameters
    ----------
    how: {'sum', 'max', 'median', 'mean'}
        'sum' for normilize by sum of intensity of all peaks. (default)
        'max' for normilize by higher intensity peak.
        'median' for normilize by median of peaks intensity.
        'mean' for normilize by mean of peaks intensity.

    Return
    ------
    pd.DataFrame
    """

    if how=='max':
        self['intensity'] /= self['intensity'].max()
    elif how=='sum':
        self['intensity'] /= self['intensity'].sum()
    elif how=='median':
        self['intensity'] /= self['intensity'].median()
    elif how=='mean':
        self['intensity'] /= self['intensity'].mean()
    else:
        raise Exception(f"There is no such mode: {how}")
    
    self.attrs['normilize'] = how

    return self

@_copy
def merge_isotopes(self) -> "pd.DataFrame":
    """
    Merge isotopes.

    For example if specrum list have 'C' and 'C_13' they will be summed in 'C' column.

    Return
    ------
    pd.DataFrame

    Caution
    -------
    Danger of lose data - with these operation we exclude data that can be usefull       
    """

    elems = find_elements(self)
    for el in elems:
        res = el.split('_')
        if len(res) == 2:
            if res[0] not in self:
                self[res[0]] = 0
            self[res[0]] = self[res[0]] + self[el]
            self = self.drop(columns=[el])
    
    self.attrs['merge_isotopes'] = True

    return self


@_copy
def calc_mass(self) -> pd.DataFrame:
    """
    Calculate mass from assigned brutto formulas and elements exact masses

    Add column "calc_mass" to self

    Return
    ------
    Spectrum
    """

    if "assign" not in self:
        raise Exception("Spectrum is not assigned")
    
    elems = find_elements(self)
    
    table = self.loc[:,elems].copy()
    
    masses = get_elements_masses(elems)

    self["calc_mass"] = table.multiply(masses).sum(axis=1)
    self["calc_mass"] = np.round(self["calc_mass"], 6)
    self.loc[self["calc_mass"] == 0, "calc_mass"] = np.nan

    return self

@_copy
def _calc_sign(self) -> str:
    """
    Determine sign from mass and calculated mass

    '-' for negative mode
    '+' for positive mode
    '0' for neutral

    Return
    ------
    str            
    """

    self = drop_unassigned(self)

    if "calc_mass" not in self:
        self = calc_mass(self)

    if "charge" not in self.columns:
        self["charge"] = 1

    value = (self["calc_mass"]/self["charge"] - self["mass"]).mean()
    value = np.round(value,4)
    if value > 1:
        return '-'
    elif value > 0.0004 and value < 0.01:
        return '+'
    else:
        return '0'

@_copy
def calc_error(self, sign: Optional[str] = None) -> pd.DataFrame:
    """
    Calculate relative and absolute error of assigned peaks from measured and calculated masses

    Add columns "abs_error" and "rel_error" to self

    Parameters
    ----------
    sign: {'-', '+', '0'}
        Optional. Default None and get from metatdata or calculated by self. 
        Mode in which mass spectrum was gotten. 
        '-' for negative mode
        '+' for positive mode
        '0' for neutral
    
    Return
    ------
    Spectrum
    """

    if "calc_mass" not in self:
        self = calc_mass(self)

    if "charge" not in self.columns:
        self["charge"] = 1

    if sign is None:
        if 'sign' in self.attrs:
            sign = self.attrs['sign']
        else:
            sign = _calc_sign(self)

    if sign == '-':
        self["abs_error"] = ((self["mass"] + (- 0.00054858 + 1.007825)) * self["charge"]) - self["calc_mass"] #-electron + proton
    elif sign == '+':
        self["abs_error"] = ((self["mass"] + 0.00054858) * self["charge"]) - self["calc_mass"]#+electron
    elif sign == '0':
        self["abs_error"] = (self["mass"] * self["charge"]) - self["calc_mass"]
    else:
        raise ValueError('Sended sign or sign in attrs is not correct. May be "+","-","0"')
    
    self["rel_error"] = self["abs_error"] / self["mass"] * 1e6
    
    return self

@_copy
def brutto(self) -> pd.DataFrame:
    """
    Calculate string with brutto from assign table

    Add column "britto" to self

    Return
    ------
    Spectrum
    """

    if "assign" not in self:
        raise Exception("Spectrum is not assigned")

    elems = find_elements(self)
    out = []
    for i, row in self.iterrows():
        s = ''
        for el in elems:
            if len(el.split('_')) == 2:
                ele = f'({el})'
            else:
                ele = el
            if row[el] == 1:
                s = s + f'{ele}'
            elif row[el] > 0:
                s = s + f'{ele}{int(row[el])}'
        out.append(s)
    
    self['brutto'] = out

    return self

@_copy
def cram(self) -> pd.DataFrame:
    """
    Mark rows that fit CRAM conditions
    (carboxylic-rich alicyclic molecules)

    Add column "CRAM" to self

    Return
    ------
    Spectrum

    References
    ----------
    Hertkorn, N. et al. Characterization of a major 
    refractory component of marine dissolved organic matter.
    Geochimica et. Cosmochimica Acta 70, 2990-3010 (2006)
    """

    if "DBE" not in self:
        self = dbe(self)        

    def check(row):
        if row['DBE']/row['C'] < 0.3 or row['DBE']/row['C'] > 0.68:
            return False
        if row['DBE']/row['H'] < 0.2 or row['DBE']/row['H'] > 0.95:
            return False
        if row['O'] == 0:
            return False
        elif row['DBE']/row['O'] < 0.77 or row['DBE']/row['O'] > 1.75:
            return False
        return True

    table = merge_isotopes(self.copy())
    self['CRAM'] = table.apply(check, axis=1)

    return self

@_copy
def ai(self) -> pd.DataFrame:
    """
    Calculate AI (aromaticity index)

    Add column "AI" to self

    Return
    ------
    Spectrum

    References
    ----------
    Koch, Boris P., and T. Dittmar. "From mass to structure: An aromaticity 
    index for high resolution mass data of natural organic matter." 
    Rapid communications in mass spectrometry 20.5 (2006): 926-932.
    """

    if "DBE_AI" not in self:
        self = dbe_ai(self)

    if "CAI" not in self:
        self = cai(self)

    self["AI"] = self["DBE_AI"] / self["CAI"]

    clear  = self["AI"].values[np.isfinite(self["AI"].values.astype('float'))].astype('float')
    self['AI'] = self['AI'].replace(-np.inf, np.min(clear))
    self['AI'] = self['AI'].replace(np.inf, np.max(clear))
    self['AI'] = self['AI'].replace(np.nan, np.mean(clear))

    return self

@_copy
def cai(self) -> pd.DataFrame:
    """
    Calculate CAI (C - O - N - S - P)

    Add column "CAI" to self

    Return
    ------
    Spectrum
    """
    
    if "assign" not in self:
        raise Exception("Spectrum is not assigned")

    table = merge_isotopes(self)

    for element in "CONSP":
        if element not in table:
            table[element] = 0

    self['CAI'] = table["C"] - table["O"] - table["N"] - table["S"] - table["P"]

    return self

@_copy
def dbe_ai(self) -> pd.DataFrame:
    """
    Calculate DBE_AI (1 + C - O - S - 0.5 * (H + N + P))

    Add column "DBE_AI" to self

    Return
    ------
    Spectrum
    """

    if "assign" not in self:
        raise Exception("Spectrum is not assigned")

    table = merge_isotopes(self)

    for element in "CHONPS":
        if element not in table:
            table[element] = 0

    self['DBE_AI'] = 1.0 + table["C"] - table["O"] - table["S"] - 0.5 * (table["H"] + table['N'] + table["P"])

    return self

@_copy
def dbe(self) -> pd.DataFrame:
    """
    Calculate DBE (1 + C - 0.5 * (H + N))

    Add column "DBE" to self

    Return
    ------
    Spectrum
    """

    if "assign" not in self:
        raise Exception("Spectrum is not assigned")

    table = merge_isotopes(self)

    for element in "CHON":
        if element not in table:
            table[element] = 0

    self['DBE'] = 1.0 + table["C"] - 0.5 * (table["H"] - table['N'])

    return self

@_copy
def dbe_o(self) -> pd.DataFrame:
    """
    Calculate DBE - O

    Add column "DBE-O" to self

    Return
    ------
    Spectrum 
    """

    if "DBE" not in self:
        self = dbe(self)

    table = merge_isotopes(self)
    self['DBE-O'] = table['DBE'] - table['O']

    return self

@_copy
def dbe_oc(self) -> pd.DataFrame:
    """
    Calculate (DBE - O) / C

    Add column "DBE-OC" to self

    Return
    ------
    Spectrum
    """

    if "DBE" not in self:
        self = dbe(self)

    table = merge_isotopes(self)
    self['DBE-OC'] = (table['DBE'] - table['O'])/table['C']

    return self

@_copy
def hc_oc(self) -> pd.DataFrame:
    """
    Calculate H/C and O/C

    Add columns "H/C" and "O/C" to self

    Return
    ------
    Spectrum
    """

    if "assign" not in self:
        raise Exception("Spectrum is not assigned")

    table = merge_isotopes(self)
    self['H/C'] = table['H']/table['C']
    self['O/C'] = table['O']/table['C']

    return self

@_copy
def kendrick(self) -> pd.DataFrame:
    """
    Calculate Kendrick mass and Kendrick mass defect

    Add columns "Ke" and 'KMD" to self

    Return
    ------
    Spectrum
    """

    if 'calc_mass' not in self:
        self = calc_mass(self)

    self['Ke'] = self['calc_mass'] * 14/14.01565
    self['KMD'] = np.floor(self['calc_mass'].values.astype('float')) - np.array(self['Ke'].values)
    self.loc[self['KMD']<=0, 'KMD'] = self.loc[self['KMD']<=0, 'KMD'] + 1

    return self

@_copy
def nosc(self) -> pd.DataFrame:
    """
    Calculate Normal oxidation state of carbon (NOSC)

    Add column "NOSC" to self

    Notes
    -----
    >0 - oxidate state.
    <0 - reduce state.
    0 - neutral state

    References
    ----------
    Boye, Kristin, et al. "Thermodynamically 
    controlled preservation of organic carbon 
    in floodplains."
    Nature Geoscience 10.6 (2017): 415-419.

    Return
    ------
    Spectrum
    """

    if "assign" not in self:
        raise Exception("Spectrum is not assigned")

    table = merge_isotopes(self)

    for element in "CHONS":
        if element not in table:
            table[element] = 0

    self['NOSC'] = 4.0 - (table["C"] * 4 + table["H"] - table['O'] * 2 - table['N'] * 3 - table['S'] * 2)/table['C']

    return self

@_copy
def mol_class(self, how: Optional[str] = None) -> pd.DataFrame:
    """
    Assign molecular class for formulas

    Add column "class" to self

    Parameters
    ----------
    how: {'kellerman', 'perminova', 'laszakovits'}
        How devide to calsses. Optional. Default 'laszakovits'

    Return
    ------
    Spectrum

    References
    ----------
    Laszakovits, J. R., & MacKay, A. A. Journal of the American Society for Mass Spectrometry, 2021, 33(1), 198-202.
    A. M. Kellerman, T. Dittmar, D. N. Kothawala, L. J. Tranvik. Nat. Commun. 2014, 5, 3804
    Perminova I. V. Pure and Applied Chemistry. 2019. Vol. 91, № 5. P. 851-864
    """

    if 'AI' not in self:
        self = ai(self)
    if 'H/C' not in self or 'O/C' not in self:
        self = hc_oc(self)

    table = merge_isotopes(self)

    for element in "CHON":
        if element not in table:
            table[element] = 0

    def get_zone_kell(row):

        if row['H/C'] >= 1.5:
            if row['O/C'] < 0.3 and row['N'] == 0:
                return 'lipids'
            elif row['N'] >= 1:
                return 'N-satureted'
            else:
                return 'aliphatics'
        elif row['H/C'] < 1.5 and row['AI'] < 0.5:
            if row['O/C'] <= 0.5:
                return 'unsat_lowOC'
            else:
                return 'unsat_highOC'
        elif row['AI'] > 0.5 and row['AI'] <= 0.67:
            if row['O/C'] <= 0.5:
                return 'aromatic_lowOC'
            else:
                return 'aromatic_highOC'
        elif row['AI'] > 0.67:
            if row['O/C'] <= 0.5:
                return 'condensed_lowOC'
            else:
                return 'condensed_highOC'
        else:
            return 'undefinded'
    
    def get_zone_perm(row):

        if row['O/C'] < 0.5:
            if row['H/C'] < 1:
                return 'condensed_tanins'
            elif row['H/C'] < 1.4:
                return 'phenylisopropanoids'
            elif row['H/C'] < 1.8:
                return 'terpenoids'
            elif row['H/C'] <= 2.2:
                if row['O/C'] < 0.25:
                    return 'lipids'
                else:
                    return 'proteins'
            else:
                return 'undefinded'
        elif row['O/C'] <= 1:
            if row['H/C'] < 1.4:
                return 'hydrolyzable_tanins'
            elif row['H/C'] <= 2.2:
                return 'carbohydrates'
            else:
                return 'undefinded'
        else:
            return 'undefinded'

    def get_zone_lasz(row):
        if row['H/C'] >= 0.86 and row['H/C'] <=1.34 and row['O/C'] >= 0.21 and row['O/C'] <=0.44:
            return 'lignin'
        elif row['H/C'] >= 0.7 and row['H/C'] <=1.01 and row['O/C'] >= 0.16 and row['O/C'] <=0.84:
            return 'tannin'
        elif row['H/C'] >= 1.33 and row['H/C'] <=1.84 and row['O/C'] >= 0.17 and row['O/C'] <=0.48:
            return 'peptide'
        elif row['H/C'] >= 1.34 and row['H/C'] <=2.18 and row['O/C'] >= 0.01 and row['O/C'] <=0.35:
            return 'lipid'
        elif row['H/C'] >= 1.53 and row['H/C'] <=2.2 and row['O/C'] >= 0.56 and row['O/C'] <=1.23:
            return 'carbohydrate'
        elif row['H/C'] >= 1.62 and row['H/C'] <=2.35 and row['O/C'] >= 0.56 and row['O/C'] <=0.95:
            return 'aminosugar'
        else:
            return 'undefinded'
    
    if how == 'perminova':
        self['class'] = table.apply(get_zone_perm, axis=1)
    elif how == 'kellerman':
        self['class'] = table.apply(get_zone_kell, axis=1)
    else:
        self['class'] = table.apply(get_zone_lasz, axis=1)

    return self

@_copy
def get_mol_class(self, how_average: str = "weight", how: Optional[str] = None) -> pd.DataFrame:
    """
    get molercular class density

    Parameters
    ----------
    how_average: {'weight', 'count'}
        how average density. Default "weight" - weight by intensity.
        Also can be "count".
    how: {'kellerman', 'perminova', 'laszakovits'}
        How devide to calsses. Optional. Default 'laszakovits'

    Return
    ------
    pandas Dataframe
    
    References
    ----------
    Laszakovits, J. R., & MacKay, A. A. Journal of the American Society for Mass Spectrometry, 2021, 33(1), 198-202.
    A. M. Kellerman, T. Dittmar, D. N. Kothawala, L. J. Tranvik. Nat. Commun. 5, 3804 (2014)
    Perminova I. V. Pure and Applied Chemistry. 2019. Vol. 91, № 5. P. 851-864
    """

    self = mol_class(drop_unassigned(self),how=how)
    count_density = len(self)
    sum_density = self["intensity"].sum()

    out = []

    if how == 'perminova':
        zones = ['condensed_tanins',
                'hydrolyzable_tanins',
                'phenylisopropanoids',
                'terpenoids',
                'lipids',
                'proteins',
                'carbohydrates',
                'undefinded']
    elif how == 'kellerman':
        zones = ['unsat_lowOC',
                'unsat_highOC',
                'condensed_lowOC',
                'condensed_highOC',
                'aromatic_lowOC',
                'aromatic_highOC',
                'aliphatics',            
                'lipids',
                'N-satureted',
                'undefinded']
    else:
        zones = ['aminosugar',
                'carbohydrate',
                'lignin',
                'lipid',
                'peptide',
                'tannin',
                'undefinded']


    for zone in zones:

        if how_average == "count":
            out.append([zone, len(self.loc[self['class'] == zone])/count_density])

        elif how_average == "weight":
            out.append([zone, self.loc[self['class'] == zone, 'intensity'].sum()/sum_density])

        else:
            raise ValueError(f"how_average should be count or intensity not {how_average}")
    
    return pd.DataFrame(data=out, columns=['class', 'density'])

@_copy
def get_dbe_vs_o(self, 
                    olim: Optional[Tuple[int, int]] = None, 
                    draw: bool = True, 
                    ax: Union[Axes, None] = None, 
                    **kwargs) -> Tuple[float, float]:
    """
    Calculate DBE vs nO by linear fit
    
    Parameters
    ----------
    olim: tuple of two int
        limit for nO. Deafult None
    draw: bool
        draw scatter DBE vs nO and how it is fitted
    ax: matplotlib axes
        ax fo outer plot. Default None
    **kwargs: dict
        dict for additional condition to scatter matplotlib

    Return
    ------
    (float, float)
        a and b in fit DBE = a * nO + b

    References
    ----------
    Bae, E., Yeo, I. J., Jeong, B., Shin, Y., Shin, K. H., & Kim, S. (2011). 
    Study of double bond equivalents and the numbers of carbon and oxygen 
    atom distribution of dissolved organic matter with negative-mode FT-ICR MS.
    Analytical chemistry, 83(11), 4193-4199.
    """

    if 'DBE' not in self:
        self = dbe(self)
    
    self = drop_unassigned(self)
    if olim is None:
        no = list(range(int(self['O'].min())+5, int(self['O'].max())-5))
    else:
        no = list(range(olim[0],olim[1]))
    
    dbe_o = []
    
    for i in no:
        dbes = self.loc[self['O'] == i, 'DBE']
        intens = self.loc[self['O'] == i, 'intensity']
        dbe_o.append((dbes*intens).sum()/intens.sum())

    def linear(x, a, b):
        return a*x + b

    x = np.array(no)
    y = np.array(dbe_o)

    popt, pcov = curve_fit(linear, x, y)
    residuals = y- linear(x, *popt)
    ss_res = np.sum(residuals**2)
    ss_tot = np.sum((y-np.mean(y))**2)
    r_squared = 1 - (ss_res / ss_tot)
    
    if draw:
        if ax is None:
            fig,ax = plt.subplots(figsize=(3,3), dpi=100)
        
        ax.scatter(x, y, **kwargs)
        ax.plot(x, linear(x, *popt), label=f'y={round(popt[0],2)}x + {round(popt[1],1)} R2={round(r_squared, 4)}', **kwargs)
        ax.set_xlim(4)
        ax.set_ylim(5)
        ax.set_xlabel('number of oxygen')
        ax.set_ylabel('DBE average')
        ax.legend()

    return popt[0], popt[1]

@_copy
def get_squares_vk(self,
                    how_average: str = 'weight',
                    ax: Union[Axes, None] = None, 
                    draw: bool = False) -> pd.DataFrame:
    """
    Calculate density in Van Krevelen diagram divided into 20 squares

    Squares index in Van-Krevelen diagram if H/C is rows, O/C is columns:
    [[5, 10, 15, 20],
        [4, 9, 14, 19],
        [3, 8, 13, 18],
        [2, 7, 12, 17],
        [1, 6, 11, 16]]

    H/C divided by [0-0.6, 0.6-1, 1-1.4, 1.4-1.8, 1.8-2.2]
    O/C divided by [0-0.25, 0.25-0.5, 0.5-0.75, 0.75-1.0]

    Parameters
    ----------
    how_average: {'weight', 'count'}
        How calculate average. My be "count" or "weight" (default)
    ax: matplotlib ax
        Optional. external ax
    draw: bool
        Optional. Default False. Plot heatmap

    Return
    ------
    Pandas Dataframe

    References
    ----------
    Perminova I. V. From green chemistry and nature-like technologies towards 
    ecoadaptive chemistry and technology // Pure and Applied Chemistry. 
    2019. Vol. 91, № 5. P. 851-864.
    """

    if 'H/C' not in self or 'O/C' not in self:
        self = drop_unassigned(hc_oc(self))

    d_table = []
    sq = []

    for y in [ (1.8, 2.2), (1.4, 1.8), (1, 1.4), (0.6, 1), (0, 0.6)]:
        hc = []
        for x in  [(0, 0.25), (0.25, 0.5), (0.5, 0.75), (0.75, 1)]:
            temp = self.copy(deep=True)
            temp = temp.loc[(temp['O/C'] >= x[0]) & (temp['O/C'] < x[1]) & (temp['H/C'] >= y[0]) & (temp['H/C'] < y[1])]

            if how_average == 'count':
                res = len(temp)/len(self)
                hc.append(res)
                sq.append(res)
            elif how_average == 'weight':
                res = temp['intensity'].sum()/self['intensity'].sum()
                hc.append(res)
                sq.append(res)
        d_table.append(hc)

    out = pd.DataFrame(data = d_table, columns=['0-0.25', '0,25-0.5','0.5-0.75','0.75-1'], index=['1.8-2.2', '1.4-1.8', '1-1.4', '0.6-1', '0-0.6'])

    if draw:
        if ax is None:
            fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
        sns.heatmap(out.round(4),cmap='coolwarm',annot=True, linewidths=.5, ax=ax)
        bottom, top = ax.get_ylim()
        plt.yticks(rotation=0)
        plt.xticks(rotation=90) 
        ax.set_ylim(bottom + 0.5, top - 0.5)

        ax.set_xlabel('O/C')
        ax.set_ylabel('H/C')

    # just for proper naming of squars. bad solution
    square = pd.DataFrame()
    square['value'] = sq
    square['square'] = [5,10,15,20,   4,9,14,19,   3,8,13,18,    2,7,12,17,   1,6,11,16]
    
    return square.sort_values(by='square').reset_index(drop=True)

@_copy
def get_mol_metrics(self, 
                    metrics: set[str], 
                    func: Optional[str] = None) -> pd.DataFrame:
    """
    Get average metrics

    Parameters
    ----------
    metrics: Sequence[str]
        Optional. Default None. Chose metrics fot watch.
    func: {'weight', 'mean', 'median', 'max', 'min', 'std'}
        How calculate average. My be "weight" (default - weight average on intensity),
        "mean", "median", "max", "min", "std" (standard deviation)

    Return
    ------
    pandas DataFrame
    """

    #self = self.calc_all_metrics().drop_unassigned().normalize()
    self = normalize(
        drop_unassigned(
            calc_all_metrics(self)
            )
            )

    if metrics is None:
        metrics = set(self.columns) - set(['intensity', 'calc_mass', 'rel_error','abs_error',
                                                'assign', 'charge', 'class', 'brutto', 'Ke', 'KMD'])

    res = []
    sorted_metrics = np.sort(np.array(list(metrics)))

    if func is None:
        func = 'weight'

    func_dict = {'mean': lambda col : np.average(self[col]),
                'weight': lambda col : np.average(self[col], weights=self['intensity']),
                'median': lambda col : np.median(self[col]),
                'max': lambda col : np.max(self[col]),
                'min': lambda col : np.min(self[col]),
                'std': lambda col : np.std(self[col])}
    if func not in func_dict:
        raise ValueError(f'not correct value - {func}')
    else:
        f = func_dict[func]

    for col in sorted_metrics:
        try:
            res.append([col, f(col)])
        except:
            res.append([col, np.nan])

    return pd.DataFrame(data=res, columns=['metric', 'value'])

@_copy
def calc_all_metrics(self) -> pd.DataFrame:
    """
    Calculated all available metrics

    Return
    ------
    Spectrum
    """

    self = calc_mass(self)
    self = calc_error(self)
    self = dbe(self)
    self = dbe_o(self)
    self = ai(self)
    self = dbe_oc(self)
    self = dbe_ai(self)
    self = mol_class(self)
    self = hc_oc(self)
    self = cai(self)
    self = cram(self)
    self = nosc(self)
    self = brutto(self)
    self = kendrick(self)

    return self