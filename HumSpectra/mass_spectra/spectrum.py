from pathlib import Path
import os
from typing import Callable, Dict, Sequence, Union, Optional, Mapping, Tuple
from functools import wraps
import copy
import json
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from scipy import spatial
from scipy.optimize import curve_fit
from scipy.spatial import cKDTree
from functools import lru_cache
from joblib import Parallel, delayed
from tqdm import tqdm


import HumSpectra.optic.utilits as ut
from .brutto import brutto_gen, elements_table, get_elements_masses

def read_mass_list(path: str,
                 sep: str = None,
                 **kwargs) -> pd.DataFrame:
    """
    :param path: путь к файлу в строчном виде,
            (example: "C:/Users/mnbv2/Desktop/lab/KNP work directory/Флуоресценция/ADOM-SL2-1.csv").
    :param sep: разделитель в строчном виде (example: ",").
    :return: DataFrame: 
    """
    if sep is None:
        sep = check_sep(path)
    try:
        data = pd.read_csv(path, sep=sep, **kwargs)
    except FileNotFoundError:
        raise FileNotFoundError(f"Файл не найден: {path}")
    except pd.errors.EmptyDataError:
        raise pd.errors.EmptyDataError(f"Файл пуст: {path}")
    except Exception as e:
        raise Exception(f"Ошибка при чтении файла: {e}")
    data = data.astype("float64")
    name = ut.extract_name_from_path(path)
    data.attrs['name'] = name


    return data


def assign(data: pd.DataFrame,
            brutto_dict: Optional[dict] = None,
            generated_bruttos_table: Optional[pd.DataFrame] = None,
            rel_error: Optional[float] = None,
            abs_error: Optional[float] = None,
            sign: str ='-',
            mass_min: Optional[float] =  None,
            mass_max: Optional[float] = None,
            intensity_min: Optional[float] =  None,
            intensity_max: Optional[float] = None,
            charge_max: int = 1,
            n_jobs=-1
    ) -> pd.DataFrame:
        """
        Assigning brutto formulas to signal by mass
        
        Parameters
        -----------
        brutto_dict: dict
            Optional. Deafault None.
            Custom Dictonary for generate brutto table.
            Example: {'C':(4, 51),'H':(4, 101),'O':(0,26), 'N':(0,4), 'C_13':(0,3)}
        generated_bruttos_table: pandas DataFrame 
            Optional. Contain column 'mass' and elements, 
            should be sorted by 'mass'.
            Can be generated by function brutto_generator.brutto_gen(). 
            if 'None' generate table with default elemnets and ranges
            C: 4-50, H 4-100, O 0-25, N 0-3, S 0-2.
        rel_error: float
            Optional. default 0.5, permissible error in ppm for assign mass to brutto formulas
        abs_error: float
            Optional. default None, permissible absolute error for assign mass to brutto formulas
        sign: str
            Optional. Deafult '-'.
            Mode in which mass spectrum was gotten. 
            '-' for negative mode
            '+' for positive mode
            '0' for neutral
        mass_min: float
            Optional. Default None. Minimall mass for assigment
        mass_max: float
            Optional. Default None. Maximum mass for assigment
        intensity_min: float
            Optional. Default None. Minimall intensity for assigment
        intensity_max: float
            Optional. Default None. Maximum intensity for assigment
        charge_max: int
            Maximum charge in m/z. Default 1.   

        Return
        ------
        pd.DataFrame 
        """

        if generated_bruttos_table is None:
            generated_bruttos_table = brutto_gen(brutto_dict)

        if mass_min is None:
            mass_min = data['mass'].min()
        if mass_max is None:
            mass_max = data['mass'].max()
        if intensity_min is None:
            intensity_min = data['intensity'].min()
        if intensity_max is None:
            intensity_max = data['intensity'].max()
        
        if sign == '-':
            mass_shift = - 0.00054858 + 1.007825  # electron and hydrogen mass
        elif sign == '+':
            mass_shift = 0.00054858  # electron mass
        elif sign == '0':
            mass_shift = 0
        else:
            raise Exception('Sended sign to assign method is not correct. May be "+","-","0"')

        data.attrs['sign':sign]

        if rel_error is not None:
            rel = True
        if abs_error is not None:
            rel = False
        if rel_error is not None and abs_error is not None:
            raise Exception('one of rel_error or abs_error must be None in assign method')
        if rel_error is None and abs_error is None:
            rel = True
            rel_error = 0.5

        data = data.loc[:,['mass', 'intensity']].reset_index(drop=True)
        table = data.copy()

        masses = generated_bruttos_table["mass"].values

        elems = list(generated_bruttos_table.drop(columns=["mass"]))
        bruttos = generated_bruttos_table[elems].values.tolist()

        # 1. Подготовка данных и KD-дерева
        masses_np = np.array(masses)
        kdtree = cKDTree(masses_np[:, np.newaxis])  # KD-дерево для быстрого поиска
        
        # Преобразуем mass_shifts в массив
        mass_shifts = np.array([mass_shifts] if isinstance(mass_shifts, (int, float)) else mass_shifts)
        
        # 2. Векторизованная фильтрация
        mask = ((table["mass"] >= mass_min) & (table["mass"] <= mass_max) &
            (table["intensity"] >= intensity_min) & (table["intensity"] <= intensity_max))
        filtered_table = table[mask].copy()
        
        # 3. Кэшируемая функция для поиска лучшей формулы
        @lru_cache(maxsize=10000)
        def find_best_formula_cached(mass, intensity):
            best = None
            min_error = float('inf')
            
            for charge in range(1, charge_max + 1):
                for shift in mass_shifts:
                    adjusted_mass = (mass + shift) * charge
                    dist, idx = kdtree.query([adjusted_mass], k=3)  # Ищем 3 ближайших
                    
                    for i, d in zip(idx[0], dist[0]):
                        current_error = (d / adjusted_mass * 1e6 / charge) if rel_error else (d * charge)
                        
                        if current_error < min_error:
                            min_error = current_error
                            best = {
                                **dict(zip(elems, bruttos[i])),
                                "assign": True,
                                "charge": charge,
                                "mass_shift": shift,
                                "error": min_error
                            }
            
            if best and ((rel_error and min_error <= rel_error) or (abs_error and min_error <= abs_error)):
                return best
            return {"assign": False}

        # 4. Параллельная обработка
        def process_row(row):
            # Используем округление для улучшения кэширования
            rounded_mass = round(row["mass"], 6)
            rounded_intensity = round(row["intensity"], 2)
            return find_best_formula_cached(rounded_mass, rounded_intensity)
        
        # Прогресс-бар для больших datasets
        results = Parallel(n_jobs=n_jobs)(
            delayed(process_row)(row) for _, row in tqdm(filtered_table.iterrows(), total=len(filtered_table)))
        
        # 5. Сбор результатов
        res = []
        res_idx = 0
        for _, row in table.iterrows():
            if mask[_[0]]:  # Проверяем, был ли пик в фильтрованной таблице
                res.append(results[res_idx])
                res_idx += 1
            else:
                res.append({"assign": False})
        

        table = table.join(res)
        data = data.merge(table, how='outer', on=list(data.columns))
        data['assign'] = data['assign'].fillna(False)
        data['charge'] = data['charge'].fillna(1)

        return data